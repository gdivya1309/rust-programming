1. Write a program to Find The Factorial using functions.
fn factorial(n: u64) -> u64 {
    (1..=n).product()
}

fn main() {
    let num = 5;
    println!("Factorial of {} is {}", num, factorial(num));
}

2. Write a function test_divisibility_by_3_4 which will check whether a given integer number is divisible by 3 or 4.
a. If the number is divisible by both return 0

b. If the number is divisible by 3 only return 1

c. If the number is divisible by 4 only return 2

d. If the number is not divisible by both, return -1
fn test_divisibility_by_3_4(n: i32) -> i32 {
    if n % 3 == 0 && n % 4 == 0 {
        0
    } else if n % 3 == 0 {
        1
    } else if n % 4 == 0 {
        2
    } else {
        -1
    }
}

fn main() {
    let num = 12;
    println!("{}", test_divisibility_by_3_4(num));
}


3. Write a program to demonstrate Pass by Value and Pass by Reference.
fn pass_by_value(mut x: i32) {
    x += 10;
    println!("Inside pass_by_value: {}", x);
}

fn pass_by_reference(x: &mut i32) {
    *x += 10;
    println!("Inside pass_by_reference: {}", x);
}

fn main() {
    let a = 5;
    pass_by_value(a);
    println!("After pass_by_value: {}", a);

    let mut b = 5;
    pass_by_reference(&mut b);
    println!("After pass_by_reference: {}", b);
}

4. Write a function calculate_area_perimeter() that takes x and y (length and width of a rectangle) as parameters and returns a tuple (area, perimeter).
fn calculate_area_perimeter(x: f64, y: f64) -> (f64, f64) {
    (x * y, 2.0 * (x + y))
}

fn main() {
    let (area, perimeter) = calculate_area_perimeter(5.0, 3.0);
    println!("Area: {}, Perimeter: {}", area, perimeter);
}

5. Write a function arr_square() that returns the Array of Squares.
fn arr_square(arr: &[i32]) -> Vec<i32> {
    arr.iter().map(|x| x * x).collect()
}

fn main() {
    let arr = [1, 2, 3, 4];
    let squares = arr_square(&arr);
    println!("{:?}", squares);
}


6. Write a recursive function fibonacci that takes a positive integer number n as a parameter and returns the nth Fibonacci term in that range.
fn fibonacci(n: u32) -> u32 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn main() {
    let n = 7;
    println!("Fibonacci term {} is {}", n, fibonacci(n));
}


7. Write a program to create a String.
fn main() {
    let s1 = String::new();
    let s2 = String::from("Hello");
    let s3 = "World".to_string();

    println!("{}, {}!", s2, s3);
}


8. Implement string manipulation operations using Core Methods of String Objects:
a. str.capacity()

b. str.contains("sub_str")

c. str.replace(replace_from, replace_to)

d. string.trim()

fn main() {
    let mut s = String::from("   Hello, Rustaceans!   ");
    println!("Capacity: {}", s.capacity());
    println!("Contains 'Rust': {}", s.contains("Rust"));
    println!("{}", s.replace("Rustaceans", "World"));
    println!("Trimmed: '{}'", s.trim());
}


9. Write a program to tokenize and iterate over a string.
fn main() {
    let s = "hello world from rust";
    for word in s.split_whitespace() {
        println!("{}", word);
    }
}

10. Write a program to push a string into a string.
fn main() {
    let mut s1 = String::from("Hello");
    let s2 = " Rust!";
    s1.push_str(s2);
    println!("{}", s1);
}


11. Write a program to find all words starting with a “c” in a string passed as a parameter. Concatenate them together and return the result.
fn concat_words_starting_with_c(s: &str) -> String {
    s.split_whitespace()
        .filter(|word| word.starts_with('c') || word.starts_with('C'))
        .collect::<Vec<&str>>()
        .join("")
}

fn main() {
    let input = "cat car dog cow catapult";
    let result = concat_words_starting_with_c(input);
    println!("{}", result);
}
